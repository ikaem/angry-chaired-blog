<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Inexperienced and curious pokes into the sprawling world of web development "/>
    

    <!--Author-->
    
        <meta name="author" content="kaem"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="WhatsApp Clone with React and Webpack: Building the App"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Inexperienced and curious pokes into the sprawling world of web development "/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Angry Chaired Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://ikaem.github.io/angry-chaired-blog/angry-chaired-blog/images/header-image.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://ikaem.github.io/angry-chaired-blog/angry-chaired-blog/images/header-image.jpg"/>
    

    <!-- Title -->
    
    <title>WhatsApp Clone with React and Webpack: Building the App - Angry Chaired Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/angry-chaired-blog/css/style.css">

    
<link rel="stylesheet" href="/angry-chaired-blog/css/custom-style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="/angry-chaired-blog/images/favicon.ico"/>
    

<meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/angry-chaired-blog/atom.xml" title="Angry Chaired Blog" type="application/atom+xml">
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/angry-chaired-blog/">Angry Chaired Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li class="">
                        <a href="/angry-chaired-blog/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li class="">
                        <a href="/angry-chaired-blog/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="">
                        <a href="/angry-chaired-blog/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li class="">
                        <a href="/angry-chaired-blog/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li class="icon-label">
                        <a target="_blank" rel="noopener" href="https://angrychaired.surge.sh">
                            
                                <i class="fa fa-user fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
                    <li class="icon-label">
                        <a target="_blank" rel="noopener" href="https://github.com/ikaem/">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
                    <li class="icon-label">
                        <a href="/angry-chaired-blog/atom.xml">
                            
                                <i class="fa fa-rss fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('evgeny-nelmin-4f8xbOP6NX4-unsplash.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>WhatsApp Clone with React and Webpack: Building the App</h1>

                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            19/09/2020
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/angry-chaired-blog/categories/whatsapp-react-webpack/">whatsapp react webpack</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- Step Content Start -->

<h4 id="Part-4-of-5-in-Whatsapp-Clone-with-React-and-Webpack"><a href="#Part-4-of-5-in-Whatsapp-Clone-with-React-and-Webpack" class="headerlink" title="Part 4 of 5 in Whatsapp Clone with React and Webpack"></a>Part 4 of 5 in Whatsapp Clone with React and Webpack</h4><p>This part actually builds the app. I know, we were supposed to make a short intro to Socket.io before we start with this part. But Socket.io is not that complicated, and I didn’t want to beat around the bush anymore. We’re doing it all together right here.</p>
<a id="more"></a>

<h4 id="See-Project-Information"><a href="#See-Project-Information" class="headerlink" title="See Project Information"></a>See <a href="#Project-Information">Project Information</a></h4><p>Still, we have to do some introduction, and we will do it in the first part. When we finally start building the app, we will do it piece by piece, by going over app features, and implementing them both on frontend and backend.</p>
<h2 id="Step-4-Building-the-app"><a href="#Step-4-Building-the-app" class="headerlink" title="Step 4: Building the app"></a>Step 4: Building the app</h2><p>Here is the plan:</p>
<ol>
<li>Setup Socket.io connection</li>
<li>Add user to the chat</li>
<li>Join every user to the default “lobby” room</li>
<li>Show all room messages</li>
<li>List and switch between available rooms</li>
<li>Send message functionality</li>
<li>Create new room</li>
<li>Join user to a room</li>
<li>Show if a new message arrived in a room that is not viewed at the moment</li>
<li>Disconnect user from the chat</li>
</ol>
<h3 id="Setup-Socket-io-connection"><a href="#Setup-Socket-io-connection" class="headerlink" title="Setup Socket.io connection"></a>Setup Socket.io connection</h3><p>As I mentioned before, we will use the <strong>MessagesProvider</strong> component to establish the Socket.io connection between the two app ends. This component wraps the entire <strong>“/chat”</strong> path of the app, so it seems like a sensible thing to do.</p>
<p>We start by importing <strong>Socket.io Client</strong> from its package we installed in the previous post:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Next, we need to create a variable that will hold a connection to the Socket.io server.<br>We will use a reference object for this purpose, which we created inside the component with the help of <strong>useRef</strong> hook.<br>Reference objects created this way persist for the entire lifetime of the component, even when the component re-renders. This is ideal for us, as we want to keep the same connection alive as long as the user is on the website.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef, createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> socketRef = useRef&lt;SocketIOClient.Socket&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MessagesContext.Provider value=&#123;<span class="literal">null</span>&#125;&gt;&#123;children&#125;&lt;/MessagesContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Few things to note:</p>
<ul>
<li><strong>useRef</strong> hook gets a generic type of <strong>SocketIOClient.Socket</strong>. I know this because I hovered over an initialized connection, and VSC tool tip told me.</li>
<li>We initialize the hook as an undefined property. This is fine, and we will give it a value soon enough.</li>
<li>I also assigned a <strong>null</strong> to the <strong>value</strong> prop on the <strong>MessagesContext.Provider</strong>. That was just for illustration purposes, and I don’t want ti to take up space. We also have to remove the generic typing for the removed object from the <strong>createContext</strong> method, leaving it just as <strong>null</strong> type for now.</li>
</ul>
<p>Ok. Now we make the connection to the Socket.io server.<br>Best place to do it, according to Interner, is in a <strong>useEffect</strong> hook. The idea is that the hook will establish a connection when the component mounts, and this connection will stay alive until the component dismounts.</p>
<p>So let’s do that.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> socketRef = useRef&lt;SocketIOClient.Socket&gt;();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loggedUser) <span class="keyword">return</span>;</span><br><span class="line">    socketRef.current = io.connect(<span class="string">&quot;localhost:5000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      socketRef.current?.emit(<span class="string">&quot;disconnect&quot;</span>, &#123; name: loggedUser &#125;);</span><br><span class="line">      socketRef.current?.disconnect();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!loggedUser) <span class="keyword">return</span> &lt;Redirect to=<span class="string">&quot;/join&quot;</span> /&gt;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As usual, few things to note:</p>
<ul>
<li>We return from the <strong>useEffect</strong> hook if there is no <strong>loggedUser</strong>. The idea is that we do not want to establish a connection if there is no logged user. This might seem unnecessary, but it solves an issue when a user access the app by entering <strong>appurl/chat</strong> directly into the browser.</li>
<li>To cement the point that no undefined users can use the app, we redirect the browser to the <strong>“/join”</strong> path in such case</li>
<li>As for the actual Socket.io connection, we do so by calling the <strong>connect</strong> method on the imported <strong>io</strong> object. We only need to pass the backend <strong>url</strong> to it, and we are good to go.</li>
<li>The connection is assigned to the reference object’s <strong>current</strong> property. This is how reference objects work. They store assigned values in the <strong>current</strong> property.</li>
<li>Finally, we want to make sure to close the connection when the component dismounts. We do that do prevent any memory leaks by keeping the connection open when it is not in use. We do it by just returning an anonymous function from the <strong>useEffect</strong> hook, in which we emit a <strong>“disconnect”</strong> event to backend, and close the connection with <strong>disconnect</strong> method.</li>
</ul>
<p>Great. So now we are connected to the Socket.io server. What do we do with this connection?</p>
<p>First’ lets set up an event listener for admin messages sent from the backend.<br>If you remember, we set up the Socket.io server in such way that it sends an admin message to the connecting socket as soon as the connection is established.<br>Here is the code in question, with the data object adjust a little bit, to fit the future shape of message objects.</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ioServer = <span class="function">(<span class="params">server: http.Server</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> io = socketio(server);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connection established on io server object</span></span><br><span class="line">  io.on(<span class="string">&quot;connect&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;We have a connection from socket nr.&quot;</span>, socket.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit admin message when connection established</span></span><br><span class="line">    socket.emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">      room: <span class="string">&quot;lobby&quot;</span>,</span><br><span class="line">      message: &#123;</span><br><span class="line">        name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        content: <span class="string">`Dear random user with socket id, <span class="subst">$&#123;socket.id&#125;</span>, welcome to the chat`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disconnect event received on the socket object</span></span><br><span class="line">    socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;User with id of&quot;</span>, socket.id, <span class="string">&quot;has disconnected&quot;</span>);</span><br><span class="line">      socket.disconnect(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ioServer;</span><br></pre></td></tr></table></figure>

<p>To receve the admin message, we will set up an event listener that waits for the <strong>“adminMessage</strong> event on frontend.<br>We could do so in the same <strong>useEffect</strong> hook in which we established the connection, but lets set up another one, so as not to clutter things too much:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  socketRef.current?.on(</span><br><span class="line">    <span class="string">&quot;adminMessage&quot;</span>,</span><br><span class="line">    (data: &#123;</span><br><span class="line">      room: <span class="built_in">string</span>;</span><br><span class="line">      message: &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        content: <span class="built_in">string</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Here is the welcome message by the admin:&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>Points:</p>
<ul>
<li>Even if we only call this <strong>useEffect</strong> hook when the component mounts, this event listener persists. It will catch all future <strong>adminMessage</strong> events.</li>
<li>We call the <strong>on</strong> method on the Socket.io connection. This is similar to what we did with the <strong>disconnect</strong> event on the server-side. The <strong>on</strong> method sits and waits for its event to come by.</li>
<li>We call this method only in case that the connection to the server exists. This is why we use that <strong>?</strong> condition on the <strong>currrent</strong> property of the reference object.</li>
</ul>
<p>Great. We established a connection, and we received and logged a message coming from backend. But, we do so only if we have a logged user in our app. So let’s make sure we have one.</p>
<h3 id="Add-user-to-the-chat"><a href="#Add-user-to-the-chat" class="headerlink" title="Add user to the chat"></a>Add user to the chat</h3><p>We add this functionality to the <strong>Join</strong> page. <strong>Join</strong> is the first component that renders once a user starts the app.</p>
<p>So what happens inside this component? Well, we already have a form in it, and we create a reference object which we attached to the form input.<br>We also accept a state setter from the <strong>App</strong> component, which we will use to store username of the user if it is available.</p>
<p>What else do we need to do?</p>
<ol>
<li>We want to have a state that stores information about current status of the user joining the app</li>
<li>We need a handler that will validate the username input and set the above-mentioned state</li>
<li>We also want a function that will send a request to the backend, to submit a selected username. We already have a function outlined in the service module (httpService.ts) that will do this job, and we will define it in this part.</li>
<li>We need to setup the backend, so it accepts the request, checks if the username is available, and return an appropriate answer.</li>
<li>Ideally, we should provide some visual feedback to the user in case their chosen username is not good.</li>
<li>If all is good, we want to redirect the borwser to the <strong>“chat/</strong> route. Specifically, we want them to join the <strong>lobby</strong> room.</li>
<li>We need to set up the automatic join to the <strong>lobby</strong> room on both frontend and backend.</li>
</ol>
<p>Alright, lets do this. Btw, we are already on line 199 in this post’s Markdown file.</p>
<h4 id="State-that-stores-information-about-current-status-of-the-user-joining-the-app"><a href="#State-that-stores-information-about-current-status-of-the-user-joining-the-app" class="headerlink" title="State that stores information about current status of the user joining the app"></a>State that stores information about current status of the user joining the app</h4><p>We start simple. We import the <strong>useState</strong> hook, and create the state.</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> JoinProps &#123;</span><br><span class="line">  setLoggedUser: React.Dispatch&lt;React.SetStateAction&lt;<span class="built_in">string</span>&gt;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Join: React.FC&lt;JoinProps&gt; = <span class="function">(<span class="params">&#123; setLoggedUser &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [isUserJoined, setIsUserJoined] = useState&lt;&#123;</span><br><span class="line">    isJoined: <span class="built_in">boolean</span>;</span><br><span class="line">    errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note the shape and initial value of the state. We have <strong>isLogged</strong> property, a <strong>boolean</strong> that tells us if the user has joined. We also have an optional <strong>errorMessage</strong> property, to which we will be assigning error messages should they come back from backend.</p>
<h4 id="Handler-that-validates-username-input-and-sets-the-state"><a href="#Handler-that-validates-username-input-and-sets-the-state" class="headerlink" title="Handler that validates username input and sets the state"></a>Handler that validates username input and sets the state</h4><p>Handler here needs to be an async function, because it will eventually call another function that fetches data from the server.</p>
<p>Apart from the async thing, there is nothing too special about this handler; it returns if the reference object’s current value is empty, and it sets state on few occasions.</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; httpJoinChat &#125; <span class="keyword">from</span> <span class="string">&quot;../services/http.service&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Join: React.FC&lt;JoinProps&gt; = <span class="function">(<span class="params">&#123; setLoggedUser &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loginInputRef = useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [isUserJoined, setIsUserJoined] = useState&lt;&#123;</span><br><span class="line">    isJoined: <span class="built_in">boolean</span>;</span><br><span class="line">    errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleJoin = <span class="keyword">async</span> (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    setIsUserJoined(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(loginInputRef.current <span class="keyword">as</span> HTMLInputElement).value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = loginInputRef.current <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; username, message &#125; = <span class="keyword">await</span> httpJoinChat(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message)</span><br><span class="line">      <span class="keyword">return</span> setIsUserJoined(&#123;</span><br><span class="line">        isJoined: <span class="literal">false</span>,</span><br><span class="line">        errorMessage: message,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    setLoggedUser(username);</span><br><span class="line">    setIsUserJoined(&#123;</span><br><span class="line">      isJoined: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;mx-auto max-w-screen-xl w-full relative bg-gray-200 xl:my-5 py-32&quot;</span>&gt;</span><br><span class="line">      &lt;form</span><br><span class="line">        onSubmit=&#123;handleJoin&#125;</span><br><span class="line">        className=<span class="string">&quot;flex flex-col w-8/12 px-4 mx-auto items-center h-32 justify-between&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;&quot;</span> className=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">          Choose your username:</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span></span><br><span class="line">          className=<span class="string">&quot;rounded-lg px-4 py-2 text-center outline-none text-gray-600&quot;</span></span><br><span class="line">          required</span><br><span class="line">          ref=&#123;loginInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button className=<span class="string">&quot;bg-green-300 py-2 px-8 rounded-lg outline-none&quot;</span>&gt;</span><br><span class="line">          Join</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>Note few things:</p>
<ul>
<li>We import the service function from <strong>http.service</strong> module. This service function returns an object with a mandatory <strong>username</strong> property, and an optional <strong>message</strong> property. We will define this function in a moment.</li>
<li>In case the message property is returned, we set the component’s state to false, and otherwise we set it to true.</li>
<li>If we don’t have a message property returned, we set the <strong>App</strong> component’s <strong>loggedUser</strong> state to the value of the <strong>username</strong> property returned by the service function, and we set the state of the <strong>Join</strong> page to <strong>true</strong>.</li>
<li>We reset the state every time the handler function is called. We do it to remove the <strong>message</strong> property in case the user’s previous username submissions were invalid.</li>
</ul>
<h4 id="Define-the-service-function"><a href="#Define-the-service-function" class="headerlink" title="Define the service function"></a>Define the service function</h4><p>Let’s go over to the <strong>http.service.ts</strong> module, and finish defining the service function we outlined there.</p>
<p>This is pretty straightforward. The function accepts <strong>username</strong> as an argument. We need it to send a POST request to the backend, and include the username in the request.<br>Then, we return an object that includes a username property, and a message property in case we get an error.</p>
<p>Here is the function:</p>
<figure class="highlight ts"><figcaption><span>src/services/http.service.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> httpJoinChat = <span class="keyword">async</span> (</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">): <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">  username: <span class="built_in">string</span>;</span><br><span class="line">  message?: <span class="built_in">string</span>;</span><br><span class="line">&#125;&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> joinPromise = <span class="keyword">await</span> fetch(ENDPOINT + <span class="string">&quot;join&quot;</span>, &#123;</span><br><span class="line">      method: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123; username: username.trim() &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> response = (<span class="keyword">await</span> joinPromise.json()) <span class="keyword">as</span> &#123;</span><br><span class="line">      username: <span class="built_in">string</span>;</span><br><span class="line">      message: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.message === <span class="string">&quot;This username is taken&quot;</span>) <span class="keyword">throw</span> response.message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; username: response.username &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error === <span class="string">&quot;This username is taken&quot;</span>) <span class="keyword">return</span> &#123; username, message: error &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      username,</span><br><span class="line">      message:</span><br><span class="line">        <span class="string">&quot;There was an issue joining the chat. Please refresh the page and try again.&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So what happens here?</p>
<ul>
<li>We have an async/await function, and inside we use <strong>fetch</strong> to get data by making a POST request. We also use <strong>try/catch</strong> blocks to decide what to do with recevied data.</li>
<li>Response that we get back has a <strong>username</strong> and <strong>message</strong> properties inside an object. If the message says that the username is taken, we throw an exception, for the catch block to deal with it. If no <strong>message</strong> of that sort, we return a simple object with that mandatory <strong>username</strong> property.</li>
<li>The catch block can either catch our thrown exception, or any other type of error. If it catches our exception, we return an object with a message property set to our exception. In any other case, the message informs about the user about chat problems.</li>
</ul>
<h4 id="Join-the-user-on-backend"><a href="#Join-the-user-on-backend" class="headerlink" title="Join the user on backend"></a>Join the user on backend</h4><p>In this part we set up the backend, so accepts the request. It needs to check if the username is available, and then it needs to return an approprite answer.</p>
<p>We already have a provisional POST route definition (<strong>“/join”</strong> path) that we made in the <strong>router.ts</strong> module in the second post of this series. Now we need to finish it.</p>
<p>First, we need to extract username property from the request body. Then, we check if this username is taken. We will create a function in the <strong>rooms.ts</strong> module that does that. Finally, we will return appropriate data.</p>
<p>To extract the username, we simply reach for the <strong>body</strong> object in the request argument that is passed to the callback of the POST request.<br>I have further destructured the <strong>username</strong> property coming from the request.</p>
<figure class="highlight ts"><figcaption><span>src/router.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">&quot;express&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reserveUsername &#125; <span class="keyword">from</span> <span class="string">&quot;./socket-io/rooms&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&quot;/&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  res.json(<span class="string">&quot;this is get&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">router.post(<span class="string">&quot;/join&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    body: &#123; username &#125;,</span><br><span class="line">  &#125; = req;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; newUser, error &#125; = reserveUsername(username <span class="keyword">as</span> <span class="built_in">string</span>); <span class="comment">// function to check if username available</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Note that I already passed the username to the function that checks validity of username. I also extracted two properties from the function: <strong>newUser</strong> and <strong>error</strong>.<br>Let’s go and create that function now.</p>
<p>We do this in the <strong>rooms</strong> module, right where we created our arrays of existing rooms and users.<br>Right now we want to define a function that loops over the <strong>users</strong> array. In case it finds an object whose username property matches our <strong>username</strong> argument, it returns an error.<br>Otherwise, it adds an object with the username argument to the array, and returns an object with this username.</p>
<p>Here is the code:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/rooms.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users: &#123; username: <span class="built_in">string</span>; socketID: <span class="built_in">string</span>; rooms: <span class="built_in">string</span>[] &#125;[] = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reserveUsername = <span class="function">(<span class="params">username: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isUsernameExist = users.find(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user.username === username;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUsernameExist)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      error: <span class="string">&quot;This username is taken&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  users.push(&#123;</span><br><span class="line">    username,</span><br><span class="line">    rooms: [],</span><br><span class="line">    socketID: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    newUser: username,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Just one thing about the function: the user object that we push into the <strong>users</strong> array still has an empty <strong>socketID</strong> property. We will give value to this property when we mount the <strong>MessagesProvider</strong> component and actually establish a Socket.io connection.</p>
<p>Back in the <strong>router.ts</strong> module, the POST route needs to check if the <strong>error</strong> property was indeed retruend from the function. If so, the object that we send to the frontend has a message property whose value is the <strong>error</strong> in question.<br>If not, we send a success message (even though this is not techically necessary, but I like to included for a possible need down the line).</p>
<p>Here is the full route code:</p>
<figure class="highlight ts"><figcaption><span>src/router.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ...</span></span><br><span class="line">router.post(<span class="string">&quot;/join&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    body: &#123; username &#125;,</span><br><span class="line">  &#125; = req;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; newUser, error &#125; = reserveUsername(username <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> res.json(&#123; username: newUser, message: error &#125;);</span><br><span class="line"></span><br><span class="line">  res.json(&#123;</span><br><span class="line">    username: newUser,</span><br><span class="line">    message: <span class="string">&quot;user has successfully joined the chat&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Provide-some-visual-feedback-to-the-joining-user"><a href="#Provide-some-visual-feedback-to-the-joining-user" class="headerlink" title="Provide some visual feedback to the joining user"></a>Provide some visual feedback to the joining user</h4><p>Alright, we are making a nice progress. We submit a username, and we get back a response informing us if the username is valid.<br>It would be nice to let the user know if their username was invalid, though. So let’s do that.</p>
<p>We do it in the <strong>Join</strong> page, and we make use of the state we have there.</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> [isUserJoined, setIsUserJoined] = useState&lt;&#123;</span><br><span class="line">  isJoined: <span class="built_in">boolean</span>;</span><br><span class="line">  errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">&#125;&gt;(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>The idea is to output the message if there is one. Since we set the state <strong>errorMessage</strong> (in the <strong>handleJoin</strong> handler function) only when we have an error, we will use that to conditionally render both the message box and its content.</p>
<p>Here is the code:</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Join: React.FC&lt;JoinProps&gt; = <span class="function">(<span class="params">&#123; setLoggedUser &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [isUserJoined, setIsUserJoined] = useState&lt;&#123;</span><br><span class="line">    isJoined: <span class="built_in">boolean</span>;</span><br><span class="line">    errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;mx-auto max-w-screen-xl w-full relative bg-gray-200 xl:my-5 py-32&quot;</span>&gt;</span><br><span class="line">      &lt;form&gt;<span class="comment">/* ... */</span>&lt;/form&gt;</span><br><span class="line">      &#123;isUserJoined.errorMessage &amp;&amp; (</span><br><span class="line">        &lt;p className=<span class="string">&quot;mt-8 px-4 text-center text-orange-900&quot;</span>&gt;</span><br><span class="line">          &#123;isUserJoined.errorMessage&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>That’s it. Easy. Now, the user gets notified both when their username is invalid, and when there is an error joining the chat.</p>
<h4 id="Redirect-the-browser-to-the-“chat-route-if-all-good"><a href="#Redirect-the-browser-to-the-“chat-route-if-all-good" class="headerlink" title="Redirect the browser to the “chat/ route if all good"></a>Redirect the browser to the <strong>“chat/</strong> route if all good</h4><p>Actually, we want to redirect the user to the <strong>lobby</strong> room if their username is confirmed as valid. Every joined user is added (will be added) to this room, so it makes sense for them to land there immediately after they join.</p>
<p>Here, we only deal with the redirect part. Next section sets up that room.</p>
<p>Ok, for this we need the <strong>Redirect</strong> component provided by <strong>React Router</strong>:</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Then, we only want to redirect when the username is actually valid. We know this by checking the state - specifically, its <strong>isJoined</strong> property.<br>If this is valid, we redirect to <strong>“/chat/room/lobby”</strong>. This is the path pattern we already set up, and it will render the <strong>Communication</strong> container.</p>
<p>Here is the code for redirecting the browser:</p>
<p>Here is the code:</p>
<figure class="highlight ts"><figcaption><span>src/pages/join.page.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Join: React.FC&lt;JoinProps&gt; = <span class="function">(<span class="params">&#123; setLoggedUser &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> [isUserJoined, setIsUserJoined] = useState&lt;&#123;</span><br><span class="line">    isJoined: <span class="built_in">boolean</span>;</span><br><span class="line">    errorMessage?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;(&#123; isJoined: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;mx-auto max-w-screen-xl w-full relative bg-gray-200 xl:my-5 py-32&quot;</span>&gt;</span><br><span class="line">      &lt;form&gt;<span class="comment">/* ... */</span>&lt;/form&gt;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">      &#123;isUserJoined.isJoined &amp;&amp; &lt;Redirect to=<span class="string">&quot;/chat/room/lobby&quot;</span> /&gt;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Done.</p>
<h4 id="Set-up-automatic-join-to-the-lobby-room"><a href="#Set-up-automatic-join-to-the-lobby-room" class="headerlink" title="Set up automatic join to the lobby room"></a>Set up automatic join to the <strong>lobby</strong> room</h4><p>Last thing to do in this part is the automatic join the the <strong>lobby</strong> room, on both frontedn and backend.</p>
<p>The frontend part is done in <strong>MessagesProvider</strong> Context component. We want to emit an event that always joins the user to the lobby when the component mounts.<br>On backend, we want to be able to react to this event. We need a check to see if the user already exists in a room (as we will use this mechanism later for other rooms). If all good, we get the admin to emit a few welcome messages.<br>Then, we return to frontend and react to these admin messages. We need an event listener for these, but we also need a state to store all messages.</p>
<p>Alright, fasten your seatbelts and let’s do this.</p>
<p><strong>The frontend part - emit the “join” event</strong>.</p>
<p>Simplest way to do this would be to just emit an <strong>“join”</strong> event from <strong>MessagesProvider</strong>‘s <strong>useEffect</strong> hook, include user and room name in it, and trust the backend to do the rest.</p>
<p>Here is how that would look like:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loggedUser) <span class="keyword">return</span> setCanUseChat(<span class="literal">false</span>);</span><br><span class="line">  socketRef.current = io.connect(process.env.API_ENDPOINT <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* the emitting part here */</span></span><br><span class="line">  socketRef.current.emit(</span><br><span class="line">    <span class="string">&quot;join&quot;</span>,</span><br><span class="line">    &#123; name: loggedUser, room: roomName &#125;,</span><br><span class="line">    (ackResponse) =&gt; <span class="built_in">console</span>.log(ackResponse)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socketRef.current?.emit(<span class="string">&quot;disconnect&quot;</span>, &#123; name: loggedUser &#125;);</span><br><span class="line">    socketRef.current?.disconnect();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>Before we move on, note the <strong>callback</strong> function passed to the <strong>emit</strong> method. We call this and <strong>acknowledgment</strong> callback (man, this is hard to spell). We use it to receive information about the event resolution on the other end. For instance, if there was an error with dealing with the event, backend would send info about it via this <strong>ack</strong> (!) function. We will get into this soon.</p>
<p>Back to emitting. The approach above works, but it would better to have a function that does that. After all, I hope that this wouldn’t be the only room that users will be joining (else this blog series becomes much shorter). If we had a function, we could use it to join users to all those other rooms that might exist in future.</p>
<p>Ok, so let’s make a function. We will do it in this component, too.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joinRoom = <span class="keyword">async</span> (roomName: <span class="built_in">string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!socketRef.current) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  roomName = roomName.trim();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> joinResponse: &#123;</span><br><span class="line">    roomName: <span class="built_in">string</span>;</span><br><span class="line">    error: <span class="built_in">string</span>;</span><br><span class="line">  &#125; = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    socketRef.current?.emit(</span><br><span class="line">      <span class="string">&quot;join&quot;</span>,</span><br><span class="line">      &#123; name: loggedUser, room: roomName &#125;,</span><br><span class="line">      (</span><br><span class="line">        ackResponse:</span><br><span class="line">          | PromiseLike&lt;&#123; roomName: <span class="built_in">string</span>; error: <span class="built_in">string</span> &#125;&gt;</span><br><span class="line">          | <span class="literal">undefined</span></span><br><span class="line">      ) =&gt; resolve(ackResponse)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> joinResponse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Yeah, this looks much different, right?<br>So what is happening here?</p>
<ul>
<li>The general idea is the same - we emit a <strong>join</strong> event, and we provide an object with the room and username properties (the latter getting its value from the function’s argument). We also include a callback function in the <strong>emit</strong> method, and finally we return the <strong>joinResponse</strong> property.</li>
<li>This function, however, is an async one. It awaits a promise (that we create), that needs to resolve to whatever is returned from the <strong>ack</strong> function. We do this whole promise thing just to be sure we can get the <strong>ackResponse</strong> value before we return the <strong>joinResponse</strong>. If we did not use the promise this way, we would return the <strong>joinResponse</strong> property before the <strong>ack</strong> function returns, and this would not be good for our code.</li>
</ul>
<p>Now, going back to the <strong>useEffect</strong> hook from before, we can call this function with the <strong>“lobby”</strong> string as an argument.<br>Since the function is an async one, we chain <strong>then()</strong> method to it, and inside we test if the <strong>emit</strong> method’s <strong>ack</strong> function returned an <strong>error</strong> property. If so, we set the state to false, causing the component to redirect back to the <strong>“/join”</strong> path.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [canUseChat, setCanUseChat] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!loggedUser) <span class="keyword">return</span> setCanUseChat(<span class="literal">false</span>);</span><br><span class="line">  socketRef.current = io.connect(process.env.API_ENDPOINT <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* the emitting part here */</span></span><br><span class="line">  joinRoom(<span class="string">&quot;lobby&quot;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data?.error) <span class="keyword">return</span> setCanUseChat(<span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socketRef.current?.emit(<span class="string">&quot;disconnect&quot;</span>, &#123; name: loggedUser &#125;);</span><br><span class="line">    socketRef.current?.disconnect();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (!canUseChat) <span class="keyword">return</span> &lt;Redirect to=<span class="string">&quot;/join&quot;</span> /&gt;;</span><br></pre></td></tr></table></figure>

<p>Sweet. This should work nicely. If only we had a backend part to support it, that is. So let’s do that, too.</p>
<p><strong>The backend part - react to the “join” event</strong></p>
<p>On backend, Socket.io server has to register the <strong>“join”</strong> event. The <strong>data</strong> object that the event listener’s callback function accepts has <strong>room</strong> and <strong>name</strong> properties.<br>The callback also includes an argument which is the <strong>ack</strong> function used on the frontend to receive the emitted event’s status.</p>
<p>Here is what I mean:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">&quot;connect&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;We have a connection&quot;</span>, socket.id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// listening for events</span></span><br><span class="line">  socket.on(<span class="string">&quot;join&quot;</span>, <span class="function">(<span class="params">data: &#123; name: <span class="built_in">string</span>; room: <span class="built_in">string</span> &#125;, ack</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    ack(&#123; roomName: data.room &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>With this approach, we call the <strong>ack</strong> function to send back an object with roomName property, which gets resolved on the frontend.</p>
<p>Let’s actually check if we can send this property back. After all, if this user doesn’t exist, or they have already joined the room, we should send an <strong>error</strong> property instead.</p>
<p>To do this, we will create another function in the <strong>rooms</strong> module on the backend.<br>This function accepts three arguments: <strong>username</strong>, <strong>room</strong>, and <strong>socketID</strong>. It returns an object with either a <strong>username</strong> property, or an <strong>error</strong> property.</p>
<p>The idea here is to first check if this room exists at all. If not, we return an error.<br>The, check if the user has its object in the <strong>users</strong> array. If not, return an error.<br>At this point, we know that the user has its object in the array.<br>Now we check if the room is already in the user’s <strong>rooms</strong> array. If yes, we return an error.<br>Before we add the room to the user’s array of rooms, we can add user’s SocketID to their object, too.<br>Now we add the room to the user’s <strong>rooms</strong> array, and return the username.</p>
<p>Here is the code for the said function.</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/rooms.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addUserToRoom = (</span><br><span class="line">  username: <span class="built_in">string</span>,</span><br><span class="line">  room: <span class="built_in">string</span>,</span><br><span class="line">  socketId?: <span class="built_in">string</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// first check if room exists at all</span></span><br><span class="line">  <span class="keyword">if</span> (!rooms.includes(room)) <span class="keyword">return</span> &#123; error: <span class="string">&quot;This room does not exist&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isUserExist = users.find(<span class="function">(<span class="params">user</span>) =&gt;</span> user.username === username);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isUserExist) <span class="keyword">return</span> &#123; error: <span class="string">&quot;This user does not exist&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isUserInRoom = isUserExist.rooms.includes(room);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUserInRoom) <span class="keyword">return</span> &#123; error: <span class="string">&quot;This user is already in the room&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add socket id to the user&#x27;s object</span></span><br><span class="line">  <span class="keyword">if</span> (socketId) isUserExist.socketID = socketId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add room to the user object</span></span><br><span class="line">  isUserExist.rooms.push(room);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// replace old user object with new user object</span></span><br><span class="line">  <span class="keyword">const</span> userIndex = users.findIndex(<span class="function">(<span class="params">user</span>) =&gt;</span> user.username);</span><br><span class="line">  users[userIndex] = isUserExist;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return username</span></span><br><span class="line">  <span class="keyword">return</span> &#123; username &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note that the <strong>socketId</strong> argument to the <strong>addUserToRoom</strong> is optional. If it exists, we will update the user’s id, if not, we won’t. Since we assign this id only when the user joins the <strong>lobby</strong> room, it makes sense to make it an optional argument.</p>
<p>Now we go back to Socket.io’s <strong>server.ts</strong> module, and get data back from this function.<br>If we manage to destructure error, we know that there is an issue, and we use the <strong>ack</strong> function to send the <strong>error</strong> property the frontend.<br>If all is good, we proceed with the join, and then use the <strong>ack</strong> function to send the <strong>roomName</strong> property to confirm that all is good.</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">&quot;join&quot;</span>, <span class="keyword">async</span> (data: &#123; name: <span class="built_in">string</span>; room: <span class="built_in">string</span> &#125;, ack) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, error &#125; = addUserToRoom(data.name, data.room, socket.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> ack(&#123; error &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    resolve(</span><br><span class="line">      socket.join(data.room, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123; name: <span class="string">&quot;admin&quot;</span>, content: <span class="string">`Welcome`</span> &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.to(data.room).emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123;</span><br><span class="line">            name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            content: <span class="string">`<span class="subst">$&#123;data.name&#125;</span> &quot;has joined the room`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        io.to(data.room).emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123;</span><br><span class="line">            name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            content: <span class="string">`You all have fun`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(socket.rooms).includes(data.room)) <span class="keyword">return</span> ack(&#123; error &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack(&#123; roomName: data.room &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Of course, there is a bit more going on here:</p>
<ul>
<li>Socket.io joining room functionality is separate from ours that we set in the <strong>rooms</strong> module. To join user to a room with Socket.io, we use the <strong>join()</strong> method.</li>
<li>The <strong>join()</strong> method is an async one, so to make sure that we don’t send any confirming <strong>acknowledgment</strong> prematurey, we make the socket’s <strong>on</strong>‘s callback an async function, and that we <strong>await</strong> for the resolution of the <strong>join()</strong> method, wrapped in a Promise.</li>
<li>The <strong>join()</strong> method accepts the room name (string), and a callback function.</li>
<li>Inside this callback function, we set few emitters to welcome the user to the room</li>
<li>First, we use the <strong>emit()</strong> method on the <strong>socket</strong> object to emit an event only to the socket that the Socket.io is currently working with.</li>
<li>The second one, <strong>to(data.room).emit(…)</strong> emits an event to everyone in the specified room, but excludes the socket itself</li>
<li>The third one, <strong>io.to(data.room).emit(…)</strong> emits an event to everyone, including the currently connected socket (the actual user that just joined).</li>
<li>Finally, we can check if the user was indeed joined the room by checking if there is key with the room’s name present in the <strong>rooms</strong> object on the <strong>socket</strong>. If not, we return an error back to frontend. If all good, we return the <strong>roomName</strong></li>
</ul>
<p><strong>Back to frontend - receive the joined room messages into the state</strong></p>
<p>Then, we return to frontend and react to these admin messages. We need an event listener for these, but we also need a state to store all messages.</p>
<p>Back to the frontend. Here, in the <strong>MessagesProvider</strong> component, we have to set up the event listener for admin messages, and have them stored inside a state.<br>While we already have an outlined event listener for <strong>adminMessage</strong> event, we do not have state for messages, so let’s do that.</p>
<p>We will, in fact, not be creating state specifically for messages. Instead, we will be creating state that is an array holding communication objects.<br>An object inside this array holds several properties:</p>
<ul>
<li><strong>room</strong>, which holds a string value representing a room that the current user has joined</li>
<li><strong>seen</strong>, holding a boolean to indicate if the newest messeages in the room have been seen by the user</li>
<li><strong>messages</strong>, an array of objects which hold two properties each: <strong>name</strong> for the message author’s name, and <strong>content</strong>, for the actual content of the message.</li>
</ul>
<p>Here is the state:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// state for communication objects...</span></span><br><span class="line">  <span class="keyword">const</span> [communicationObjects, setCommunicationObjects] = useState&lt;</span><br><span class="line">    &#123;</span><br><span class="line">      room: <span class="built_in">string</span>;</span><br><span class="line">      seen: <span class="built_in">boolean</span>;</span><br><span class="line">      messages: &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;[];</span><br><span class="line">    &#125;[]</span><br><span class="line">  &gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Nice. Now when we have the state, we want to store new messages arriving from backedn to this state.</p>
<p>Best place to do it is the <strong>useEffect</strong>, the same one where we have the event listner for the <strong>adminMessage</strong> event.</p>
<p>How to approach this? How about a function that gets called every time when we receive a new message.<br>This function should check if the communication object for the room to which the message has arrived already exists in the state.<br>If not, a new object should be created, with the new message added to it, and then appended to the state.<br>If the room’s communication object exists, we update the state by adding the message to the communication object’s messages array.</p>
<p>One little thing, though, is that we need to use the state setter that accepts a function instead of the one that accepts the actual array to be the state. This is because we need access to the newest state to check if a communication object already exists.<br>In fact, we will do all our checks insite the setter’s callback function, and use the created function only to to provide arguments, and the logic in one place.</p>
<p>Here are both the function and the modified event listener, defined in a <strong>useEffect</strong> hook. Note that this is a new <strong>useEffect</strong> hook that we set up specifically for this purpose.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> addToCommunicationObjects = (</span><br><span class="line">    roomName: <span class="built_in">string</span>,</span><br><span class="line">    message: &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    setCommunicationObjects(<span class="function">(<span class="params">prevObjs</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isRoomExist = prevObjs.find(<span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> room.room === roomName;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isRoomExist)</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          &#123; room: roomName, seen: <span class="literal">false</span>, messages: [message] &#125;,</span><br><span class="line">          ...prevObjs,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> newMessages = [...isRoomExist.messages, message];</span><br><span class="line">      <span class="keyword">const</span> newObj = &#123;</span><br><span class="line">        room: roomName,</span><br><span class="line">        seen: <span class="literal">false</span>,</span><br><span class="line">        messages: newMessages,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> remainingObjs = prevObjs.filter(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.room !== roomName;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [newObj, ...remainingObjs];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  socketRef.current?.on(</span><br><span class="line">    <span class="string">&quot;adminMessage&quot;</span>,</span><br><span class="line">    (data: &#123;</span><br><span class="line">      room: <span class="built_in">string</span>;</span><br><span class="line">      message: &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        content: <span class="built_in">string</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;) =&gt; &#123;</span><br><span class="line">      addToCommunicationObjects(data.room, data.message);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Few things:</p>
<ul>
<li>Inside the state setter, we use previous state to find our if a communication object for the argument room already exists. If not, we return an array with a new object spread into an array together with previous state objects</li>
<li>This new object uses the <strong>roomName</strong> argument as the value of its <strong>room</strong> property, sets the <strong>seen</strong> property to false as the newest message hasn’t been seen yet, and adds the <strong>message</strong> argument into the <strong>messages</strong> array as the only message</li>
<li>In case the communication object does exist, we spread all its messages, toghether with the new message, into a new array. Then we create a new object with needed properties. We also create a new array that does not hold the communication object for the room we need. Finally, we return an array with the freshly created communication object, and old filtered communicaiton objects spread into it.</li>
<li>As for the event listener, the poor guy only calls the function above and provides it with room name and the message.</li>
</ul>
<p>Alright. That was a lot. But we did join a user to the chat, and made them a part of the <strong>lobby</strong> room. Happy times.</p>
<h3 id="Show-all-room-messages"><a href="#Show-all-room-messages" class="headerlink" title="Show all room messages"></a>Show all room messages</h3><p>At the moment, when the user is redirected to the <strong>“/chat/</strong> path, they wont really see what rooms they can view, nor will any messages be shown to them.<br>Let’s start fixing this by showing them all messages of the <strong>lobby</strong> room first.</p>
<p>How do we approach this?</p>
<ul>
<li>We need to pass only a specific messages to the <strong>Communication</strong> container. We can do so with a function that accepts a <strong>room</strong> argument, based on which the function will select the correct object and grab its messages.</li>
<li>We do passing via Context</li>
<li>Inside the <strong>Communication</strong> container, we should get the current path’s id, to be used for fetching each room’s messages. We can do that with the <strong>useParams</strong> hook provided by React Router.</li>
<li>We can use this <strong>id</strong> as the <strong>roomName</strong> prop value on the <strong>CommunicationHeader</strong> component.</li>
<li>We need to map over the communication object’s messages and render a <strong>CommunicationMessage</strong> component for each message in the array, passing it information about each message.</li>
</ul>
<p><strong>Create function to get room messages</strong></p>
<p>Let’s start with that function.<br>The function needs only one argument, name of the room. It uses it to search over the <strong>communicationObjects</strong> state. If it finds an object, it returns its <strong>messages</strong> property. If not, it returns an empty array.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRoomMessages = <span class="function">(<span class="params">room: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> roomMessages = communicationObjects.find(<span class="function">(<span class="params"><span class="built_in">object</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object</span>.room === room;</span><br><span class="line">  &#125;) <span class="keyword">as</span> &#123;</span><br><span class="line">    room: <span class="built_in">string</span>;</span><br><span class="line">    seen: <span class="built_in">boolean</span>;</span><br><span class="line">    messages: &#123;</span><br><span class="line">      name: <span class="built_in">string</span>;</span><br><span class="line">      content: <span class="built_in">string</span>;</span><br><span class="line">    &#125;[];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> roomMessages?.messages || [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note the <strong>optional chaining operator - ?.</strong>. In case there is a <strong>roomMessages</strong> object, it will allow evaluation of the <strong>messages</strong> property inside it. If not, the <strong>roomMessages</strong> statement is ignored, and evaluation continues to the empty array.</p>
<p><strong>Add the function to “MessagesContext”</strong></p>
<p>Now that we have the function, we can add it to the MessagesContext <strong>value</strong> prop.<br>First, we need to add it to the generic types of the MessagesContext, and then we can add it to the <strong>value</strong> prop.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MessagesContext = createContext&lt;&#123;</span><br><span class="line">  loggedUser: <span class="built_in">string</span>;</span><br><span class="line">  getRoomMessages: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;[];</span><br><span class="line">&#125; | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>Here, we specify that the context can be an object with out function that accepts a string argument, and returns an array of objects.<br>The context can also be of <strong>null</strong> type, since its initial value is <strong>null</strong></p>
<p>Now we can add the function to the object held inside the context’s value prop:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;MessagesContext.Provider</span><br><span class="line">    value=&#123;&#123;</span><br><span class="line">      getRoomMessages,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;children&#125;</span><br><span class="line">  &lt;/MessagesContext.Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Great. We have the function available via contect. Let’s go ovet to the <strong>Communicaiton</strong> container, and get it from the context.</p>
<p>To get data from the context, we have to import the context in question into the component, and then use React’s <strong>useContext</strong> hook to get the needed property.</p>
<p>Here is the whole thing here:</p>
<figure class="highlight ts"><figcaption><span>src/containers/communicaiton.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext, useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MessagesContext &#125; <span class="keyword">from</span> <span class="string">&quot;../contexts/messages.context&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Communication: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; getRoomMessages &#125; = useContext(MessagesContext) <span class="keyword">as</span> &#123;</span><br><span class="line">    getRoomMessages: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;[];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note that I cast the function destructured from the context as a function that we defined in the context. I do this because TS knows that <strong>MessagesContext</strong> can hold a <strong>null</strong> value as well, and I want to tell it that this is not such case.</p>
<p><strong>Get the current path’s id</strong></p>
<p>We can get current path <strong>id</strong> with React Router’s <strong>useParams</strong> hook.<br>Here is the hook’s import and destructuring to get the <strong>id</strong>:</p>
<figure class="highlight ts"><figcaption><span>src/containers/communicaiton.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Communication: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = useParams&lt;&#123; id: <span class="built_in">string</span> &#125;&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Use the “id” as the “roomName” prop value on the “CommunicationHeader” component.</strong></p>
<p>Not much to this. Since <strong>id</strong> holds the room’s name, we just pass it to the <strong>CommunicationHeader</strong>, whih will render it as the current room’s name.</p>
<figure class="highlight ts"><figcaption><span>src/containers/communicaiton.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;main className=<span class="string">&quot;row-span-2 flex flex-col h-full&quot;</span>&gt;</span><br><span class="line">    &lt;CommunicationHeader roomName=&#123;id&#125; /&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>Map over the communication object’s messages and render a “CommunicationMessage” component for each message</strong></p>
<p>We can now use both the passed function and the <strong>id</strong> property to get messages for each room.<br>We will just call it here, and map over its return, setting each message’s properties as props on the <strong>CommunicationMessage</strong> component.</p>
<figure class="highlight ts"><figcaption><span>src/containers/communicaiton.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  getRoomMessages(id).map(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;CommunicationMessage</span><br><span class="line">        name=&#123;val.name&#125;</span><br><span class="line">        loggedUser=&#123;loggedUser&#125;</span><br><span class="line">        content=&#123;val.content&#125;</span><br><span class="line">        key=&#123;index&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And that is it. When the user joins the chat, they will be redirect to the path with <strong>lobby</strong> id. This will make <strong>Communicaation</strong> container fetch all messages belonging to this room, and the user will see those admin messages rendered on the screen.</p>
<h3 id="List-and-switch-between-available-rooms"><a href="#List-and-switch-between-available-rooms" class="headerlink" title="List and switch between available rooms"></a>List and switch between available rooms</h3><p>While the user can see the lobby messages on the screen, they won’t see a list of their rooms anywhere. Granted, there is only one room they have joined at the moment, but come on, more will come.</p>
<p>So let’s fix this.<br>We want to get all available rooms from the <strong>communicationObjects</strong> state in the <strong>MessagesProvider</strong> component, and pass it as a list to the <strong>Contacts</strong> container.</p>
<p>The flow of this is very similar to the previous one:</p>
<ul>
<li>We generate a list of all rooms, together with some basic rooms data.</li>
<li>We pass this list to the <strong>Contacts</strong> container</li>
<li>We loop over the list of rooms, and render a <strong>ContactItem</strong> component for each item in the room list</li>
<li>We set up the <strong>ContactItem</strong> component to link to a path that will render its room’s messages</li>
</ul>
<p><strong>Generate the room list</strong></p>
<p>To get a list of rooms the user is a part of, we will create a function in the <strong>MessagesProvider</strong> component.<br>We want this function to return an array of objects, with each object holding the following:</p>
<ul>
<li>Name of the room</li>
<li>A <strong>seen</strong> property, to indicate if the newest room message has been seen by the user</li>
<li>Information about the last message in the room: author and the content</li>
</ul>
<p>Ok, here is the function definition in <strong>MessagesProvider</strong>:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateCommunicationList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> communicationObjects.map(<span class="function">(<span class="params">commObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      room: commObj.room,</span><br><span class="line">      seen: commObj.seen,</span><br><span class="line">      lastMessage: &#123;</span><br><span class="line">        author: commObj.messages[commObj.messages.length - <span class="number">1</span>].name,</span><br><span class="line">        content: commObj.messages[commObj.messages.length - <span class="number">1</span>].content,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Pass the “communicationList” function to the “Contacts” container</strong></p>
<p>Same as we did with <strong>getRoomMessages</strong> function, we need to add this function’s type to the context’s generic types, before we can pass it on to ther components</p>
<p>Here are both the typing and the passing:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MessagesContext = createContext&lt;&#123;</span><br><span class="line">  loggedUser: <span class="built_in">string</span>;</span><br><span class="line">  getRoomMessages: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;[] | [];</span><br><span class="line">  generateCommunicationList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    room: <span class="built_in">string</span>;</span><br><span class="line">    seen: <span class="built_in">boolean</span>;</span><br><span class="line">    lastMessage: &#123;</span><br><span class="line">      author: <span class="built_in">string</span>;</span><br><span class="line">      content: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;[];</span><br><span class="line">&#125; | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MessagesContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        getRoomMessages,</span><br><span class="line">        generateCommunicationList,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/MessagesContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Now we grab the said function inside the <strong>Contacts</strong> container.<br>Note the casting again - done to assure TS that at this point the context is not <strong>null</strong> anymore.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/contacts.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; MessagesContext &#125; <span class="keyword">from</span> <span class="string">&quot;../contexts/messages.context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Contacts: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; generateCommunicationList &#125; = useContext(MessagesContext) <span class="keyword">as</span> &#123;</span><br><span class="line">    generateCommunicationList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      room: <span class="built_in">string</span>;</span><br><span class="line">      seen: <span class="built_in">boolean</span>;</span><br><span class="line">      lastMessage: &#123;</span><br><span class="line">        author: <span class="built_in">string</span>;</span><br><span class="line">        content: <span class="built_in">string</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;[];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Render a **ContactItem</strong> component for each item returned by communicationList**</p>
<p>There is not much to this part, either (I hope it stays like this until the end, because we are at line 1082 already…).<br>We just have to loop over the returned array, render <strong>ContactItem</strong> for each array item, and pass it the array objects’ properties as props.</p>
<p>Here it is:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/contacts.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; MessagesContext &#125; <span class="keyword">from</span> <span class="string">&quot;../contexts/messages.context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Contacts: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; generateCommunicationList &#125; = useContext(MessagesContext) <span class="keyword">as</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;bg-white custom-scrollbar overflow-y-scroll px-4&quot;</span>&gt;</span><br><span class="line">      &lt;ul className=<span class="string">&quot;w-full&quot;</span>&gt;</span><br><span class="line">        &#123;generateCommunicationList().map(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;ContactItem</span><br><span class="line">              room=&#123;val.room&#125;</span><br><span class="line">              seen=&#123;val.seen&#125;</span><br><span class="line">              content=&#123;val.lastMessage.content&#125;</span><br><span class="line">              author=&#123;val.lastMessage.author&#125;</span><br><span class="line">              key=&#123;index&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Yes. Elements’ <strong>index</strong>es should not be used as <strong>keys</strong>, but this is a provisional thing. Next series will have rooms stored in a database, each reaceving their own unique id that we will use as <strong>key</strong> here.</p>
<p>Other than that, we are fine.</p>
<p>Let’s move into the <strong>ContactItem</strong> component to proper render the received props, and link room names to their room paths.</p>
<p><strong>Set up the “ContactItem” component</strong></p>
<p>The code below includes both the linking and rendering of the props.</p>
<p>To link to the correct URL inside the app, we use <strong>React Router</strong>‘s <strong>Link</strong> component. The component’s <strong>“to”</strong> prop holds a string of the pattern that we already established - <strong>“/chat/room/<ROOM_NAME>“</strong>.<br>When the user clicks on the link and the browser takes them to the room’s path, the <strong>Communication</strong> container will extract the <strong>ROOM_NAME</strong> part from the URL. Then, it will use it to fetch appropriate room message from the context, and render them on screen.</p>
<p>We also hardcode the date of the last message. We will have this as a dynamic render in the next series.</p>
<figure class="highlight ts"><figcaption><span>src/components/contact-item.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ContactItemProps &#123;</span><br><span class="line">  room: <span class="built_in">string</span>;</span><br><span class="line">  seen: <span class="built_in">boolean</span>;</span><br><span class="line">  author: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ContactItem: React.FC&lt;ContactItemProps&gt; = (&#123;</span><br><span class="line">  room,</span><br><span class="line">  seen,</span><br><span class="line">  author,</span><br><span class="line">  content,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Link to=&#123;<span class="string">`/chat/room/<span class="subst">$&#123;room&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;li className=<span class="string">&quot;flex justify-start py-4 border-b w-full&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;w-12&quot;</span>&gt;</span><br><span class="line">          &lt;img</span><br><span class="line">            src=<span class="string">&quot;https://source.unsplash.com/100x100/?portrait&quot;</span></span><br><span class="line">            alt=<span class="string">&quot;&quot;</span></span><br><span class="line">            className=<span class="string">&quot;w-full rounded-full&quot;</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;sm:flex justify-start flex-wrap ml-4 w-4/6 items-center hidden&quot;</span>&gt;</span><br><span class="line">          &lt;span className=<span class="string">&quot;&quot;</span>&gt;&#123;room&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">          &lt;span className=<span class="string">&quot;text-xs ml-auto text-gray-500&quot;</span>&gt; Yesterday &lt;/span&gt;</span><br><span class="line">          &lt;p className=&#123;<span class="string">`text-sm w-full`</span>&#125;&gt;</span><br><span class="line">            &#123;author&#125;: &#123;content&#125;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ContactItem;</span><br></pre></td></tr></table></figure>

<p>Note that we are not doing anything with the <strong>seen</strong> property yet. We are saving that for later.</p>
<p>With this, though, the app should be able to render old and new rooms easily. If only we had any new rooms to render…</p>
<h3 id="Send-message-functionality"><a href="#Send-message-functionality" class="headerlink" title="Send message functionality"></a>Send message functionality</h3><p>Before we start adding new rooms to the app, let’s make sure the user can actually contribute some messages to their existing rooms.</p>
<p>Here is how I imagine this to work:</p>
<ul>
<li><strong>Communication</strong> container provides a reference object to the <strong>CommunicationNewMessage</strong> form component, to use as a reference on its form input. We have already done this</li>
<li>The container also has a defined <strong>handler</strong> function that validates the input value provided by the reference object, and reacts to the form submission only if it is done by pressing the <strong>“Enter”</strong> key. The handler function calls a method that emits new message event to the backend, and then resets the form input to prepare it for next message.</li>
<li>The handler is passed to the form component, too, and called when the form is submitted.</li>
<li>The emitting function is defined in the <strong>MessagesProvider</strong> component. It accepts the room name as an argument, and the actual message content. The data that its message event emits holds the two property, as well as the name of the logged user.</li>
<li>On the backend, an event listener waits for the new message event. In an ideal world, it would store the message into a database, but we will only emit this same message back to every socket that is in the room from which the message was sent.</li>
<li>Back on the frontend, we set up an event listener that catches room messages sent from the Socket.io server. The listener then adds new message to the state.</li>
</ul>
<h4 id="Define-function-to-handle-message-submission"><a href="#Define-function-to-handle-message-submission" class="headerlink" title="Define function to handle message submission"></a>Define function to handle message submission</h4><p>This function is defined in the <strong>Communication</strong> container.<br>We need it to accept an event, and make sure that it allows its body execution only if the “Enter” key is pressed and if the actual input value is valid.</p>
<p>Here is the full handler function:</p>
<figure class="highlight ts"><figcaption><span>src/containers/communication.container.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; MessagesContext &#125; <span class="keyword">from</span> <span class="string">&quot;../contexts/messages.context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Communication: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> &#123; sendMessage, getRoomMessages &#125; = useContext(MessagesContext) <span class="keyword">as</span> &#123;</span><br><span class="line">    sendMessage: <span class="function">(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    getRoomMessages: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;[];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleNewMessage = <span class="function">(<span class="params">e: React.KeyboardEvent&lt;HTMLFormElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key !== <span class="string">&quot;Enter&quot;</span> || !newMessageRef.current) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    sendMessage(id, newMessageRef.current.value);</span><br><span class="line">    (newMessageRef.current <span class="keyword">as</span> HTMLTextAreaElement).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Few things to note:</p>
<ul>
<li>The event that gets passed to the function is of a generic <strong>React.KeyboardEvent</strong> type with an argument of the <strong>HTMLFormElement</strong> type. This is caused by the event that called the function in the <strong>CommunicationNewMessage</strong> component being <strong>onKeyPress</strong>.</li>
<li>To make sure that pressing on the “Enter” key while submitting the message doesn’t create a new line in the input field, too, we use <strong>preventDefault()</strong> to prevent this from happening.</li>
<li>We call the event emitting function, which we will define in a moment</li>
<li>Finally, we reset the value of our message input</li>
</ul>
<h3 id="Use-the-handler-in-“CommunicationNewMessage”-component"><a href="#Use-the-handler-in-“CommunicationNewMessage”-component" class="headerlink" title="Use the handler in “CommunicationNewMessage” component"></a>Use the handler in “CommunicationNewMessage” component</h3><p>Aside from the handler being called by the <strong>onKeyPress</strong> event, there is not much here.</p>
<p>Assuming we passed it to the form component, we type and use it there:</p>
<figure class="highlight ts"><figcaption><span>src/components/communication-new-message.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; RefObject &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> CommunicationNewMessageProps &#123;</span><br><span class="line">  newMessageRef: RefObject&lt;HTMLTextAreaElement&gt;;</span><br><span class="line">  handleNewMessage: <span class="function">(<span class="params">a: React.KeyboardEvent&lt;HTMLFormElement&gt;</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CommunicationNewMessage: React.FC&lt;CommunicationNewMessageProps&gt; = (&#123;</span><br><span class="line">  newMessageRef,</span><br><span class="line">  handleNewMessage,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form</span><br><span class="line">      onKeyPress=&#123;handleNewMessage&#125;</span><br><span class="line">      className=<span class="string">&quot;mt-auto pl-2 pr-4 py-2 h-16 flex items-center justify-center&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;&quot;</span> hidden&gt;</span><br><span class="line">        New message</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;textarea</span><br><span class="line">        name=<span class="string">&quot;&quot;</span></span><br><span class="line">        id=<span class="string">&quot;&quot;</span></span><br><span class="line">        cols=&#123;<span class="number">30</span>&#125;</span><br><span class="line">        rows=&#123;<span class="number">2</span>&#125;</span><br><span class="line">        placeholder=<span class="string">&quot;Write a message&quot;</span></span><br><span class="line">        className=<span class="string">&quot;custom-scrollbar h-full w-full rounded-full p-3 text-gray-800 outline-none&quot;</span></span><br><span class="line">        ref=&#123;newMessageRef&#125;</span><br><span class="line">        style=&#123;&#123; resize: <span class="string">&quot;none&quot;</span> &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CommunicationNewMessage;</span><br></pre></td></tr></table></figure>

<h4 id="Define-the-emitting-function"><a href="#Define-the-emitting-function" class="headerlink" title="Define the emitting function"></a>Define the emitting function</h4><p>The emitting function is defined in the <strong>MessagesProvider</strong> component.<br>It only needs two arguments, and then it does its job by calling the <strong>emit</strong> method if the connection’s reference object is actually valid:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sendMessage = <span class="function">(<span class="params">room: <span class="built_in">string</span>, message: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  message = message.trim();</span><br><span class="line"></span><br><span class="line">  socketRef.current?.emit(<span class="string">&quot;message&quot;</span>, &#123; name: loggedUser, room, message &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The event that we emit from frontend to the backend to submit a new message is <strong>“message”</strong>.</p>
<p>Of course, we need to type this message before we pass it on from the context and cast is as a valid value in the receiving component. But we already know how to do that.</p>
<h4 id="Receive-new-message-on-backend-and-emitting-it-back-to-the-whole-room-on-frontend"><a href="#Receive-new-message-on-backend-and-emitting-it-back-to-the-whole-room-on-frontend" class="headerlink" title="Receive new message on backend and emitting it back to the whole room on frontend"></a>Receive new message on backend and emitting it back to the whole room on frontend</h4><p>To be able to receive a new message event on backend, we set up an event listener.<br>It is pretty simple this one: we get the event’s data, and then we emit another event back to frontend. The rerouted event is called <strong>roomMessage</strong>, to make it easier for us to differentiate messages coming from and to frontend.</p>
<p>Here is the event listener:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">socket.on(</span><br><span class="line">  <span class="string">&quot;message&quot;</span>,</span><br><span class="line">  (data: &#123; name: <span class="built_in">string</span>; room: <span class="built_in">string</span>; message: <span class="built_in">string</span> &#125;) =&gt; &#123;</span><br><span class="line">    io.to(data.room).emit(<span class="string">&quot;roomMessage&quot;</span>, &#123;</span><br><span class="line">      room: data.room,</span><br><span class="line">      message: &#123;</span><br><span class="line">        name: data.name,</span><br><span class="line">        content: data.message,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Just two things:</p>
<ul>
<li>We use <strong>emit</strong> method on the <strong>io</strong> instance of the Socket.io server, to make sure that the message goes to the whole room, including the message author.</li>
<li>We also re-shape the message data a bit, to make it ready to be easily added to <strong>communicationObjects</strong> state in the <strong>MessagesProvider</strong> component on frontend.</li>
</ul>
<h4 id="Frontend-event-listener-for-new-room-message"><a href="#Frontend-event-listener-for-new-room-message" class="headerlink" title="Frontend event listener for new room message"></a>Frontend event listener for new room message</h4><p>Of course, now that we emit a <strong>roomMessage</strong> event on backend, we have to catch it on frontend.</p>
<p>We set up an event listener that does that. Similar to the <strong>adminMessage</strong> event listener (which could totally be merged into this new one), we accept the data from the event, and then call the <strong>addToCommunicationObjects</strong> function to add new message to the state.<br>We do this in the same <strong>useEffect</strong> hook where the event listener for <strong>adminMessage</strong> event lives.</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// adding room messages from server to the state</span></span><br><span class="line">    <span class="keyword">const</span> addToCommunicationObjects = (</span><br><span class="line">      roomName: <span class="built_in">string</span>,</span><br><span class="line">      message: &#123; name: <span class="built_in">string</span>; content: <span class="built_in">string</span> &#125;</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    socketRef.current &amp;&amp;</span><br><span class="line">      socketRef.current?.on(</span><br><span class="line">        <span class="string">&quot;roomMessage&quot;</span>,</span><br><span class="line">        (data: &#123;</span><br><span class="line">          room: <span class="built_in">string</span>;</span><br><span class="line">          message: &#123;</span><br><span class="line">            name: <span class="built_in">string</span>;</span><br><span class="line">            content: <span class="built_in">string</span>;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;) =&gt; &#123;</span><br><span class="line">          addToCommunicationObjects(data.room, data.message);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    socketRef.current?.on(</span><br><span class="line">      <span class="string">&quot;adminMessage&quot;</span>,</span><br><span class="line">      (data: &#123;</span><br><span class="line">        room: <span class="built_in">string</span>;</span><br><span class="line">        message: &#123;</span><br><span class="line">          name: <span class="built_in">string</span>;</span><br><span class="line">          content: <span class="built_in">string</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;) =&gt; &#123;</span><br><span class="line">        addToCommunicationObjects(data.room, data.message);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>That’s all we need to do. Now, with every new message that comes with the <strong>roomMessage</strong> event, the <strong>addToCommunicationObjects</strong> function is called and the message is added to the state. Because of it, the <strong>MessagesProvider</strong> rerenders, causing its child components to do so as well.</p>
<h3 id="Create-new-room-functionality"><a href="#Create-new-room-functionality" class="headerlink" title="Create new room functionality"></a>Create new room functionality</h3><p>Finally, we get to make a way for the user to create a new room.<br>How would that work?</p>
<p>Well, we already have a component that should do the job - <strong>NewRoom</strong>. It renders a from with with a single input, and it can be access at <strong>/chat/new-room</strong> path.<br>The component already has a reference object attached to the input, too, so we can easily extract the new room’s name when the user enters it.</p>
<p>Left to do is the logic:</p>
<ul>
<li>We need a to create a handler that validates the input value. The handler should call a function that emits an event to create a new room on the backend.</li>
<li>We should also have a way to inform the user of unsuccessful room creation, or redirect them to the new room in case the room creation was a success.</li>
<li>The emitter function sends an event to the backend, and waits for the acknowledgment function to return information about new room status before it returns.</li>
<li>On backend, we setup an event listener that reacts to our event. The event listener creates the room only if it doesn’t exist already, and calls acknowledgment function to confirm the new room creation. Otherwise it sends an error to frontend via acknowledgment function. We also want to make sure that the user is immediately added to the new room, so we do that on the backend as well.</li>
</ul>
<h4 id="The-handler-function"><a href="#The-handler-function" class="headerlink" title="The handler function"></a>The handler function</h4><p>We create the handler function in the <strong>NewRoom</strong> component.<br>As usualy, it needs to validate the input, and after calling the function that will emit the event to create a new room, it should either inform the user of an error, or redirect them to the new room.</p>
<p>To be able to give error feedback and redirect the browser, we will add state to the component, and import the <strong>Redirect</strong> component from React Router.</p>
<p>Here is the code, toghether with the component’s state implemented:</p>
<figure class="highlight ts"><figcaption><span>src/component/communication-new-room.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useState, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; MessagesContext &#125; <span class="keyword">from</span> <span class="string">&quot;../contexts/messages.context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewRoom: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newRoomInputRef = useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; addNewRoom &#125; = useContext(MessagesContext) <span class="keyword">as</span> &#123;</span><br><span class="line">    addNewRoom: (</span><br><span class="line">      a: <span class="built_in">string</span></span><br><span class="line">    ) =&gt; <span class="built_in">Promise</span>&lt;&#123;</span><br><span class="line">      roomName: <span class="built_in">string</span>;</span><br><span class="line">      error: <span class="built_in">string</span>;</span><br><span class="line">    &#125;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isCreated, setIsCreated] = useState&lt;&#123;</span><br><span class="line">    status: <span class="built_in">boolean</span>;</span><br><span class="line">    message: <span class="built_in">string</span>;</span><br><span class="line">    createdRoomRoute: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;(&#123;</span><br><span class="line">    status: <span class="literal">false</span>,</span><br><span class="line">    message: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    createdRoomRoute: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleNewRoomSubmit = <span class="keyword">async</span> (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if input empty</span></span><br><span class="line">    <span class="keyword">if</span> (!(newRoomInputRef.current <span class="keyword">as</span> HTMLInputElement).value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      roomName,</span><br><span class="line">      error,</span><br><span class="line">    &#125;: &#123; roomName?: <span class="built_in">string</span>; error?: <span class="built_in">string</span> &#125; = (<span class="keyword">await</span> addNewRoom(</span><br><span class="line">      (newRoomInputRef.current <span class="keyword">as</span> HTMLInputElement).value</span><br><span class="line">    )) <span class="keyword">as</span> &#123;</span><br><span class="line">      roomName: <span class="built_in">string</span>;</span><br><span class="line">      error: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if error, update state message to error</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      setIsCreated(&#123;</span><br><span class="line">        status: <span class="literal">false</span>,</span><br><span class="line">        message: error,</span><br><span class="line">        createdRoomRoute: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reroute to the actual joined room</span></span><br><span class="line">    setIsCreated(&#123;</span><br><span class="line">      status: <span class="literal">true</span>,</span><br><span class="line">      message: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      createdRoomRoute: roomName,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Ok, so what is goind on here, beside importing the hooks and getting data from the context?</p>
<ul>
<li>The <strong>addNewRoom</strong> function fetched from the context is the emitter function. We will defined it in a moment.</li>
<li>The emitter function, however, will we an async one, returning a promise. We do it to be able to await its resolution before we either set the state to <strong>true</strong> or <strong>false</strong></li>
<li>In case the emitter returns the <strong>error</strong> property, the state <strong>status</strong> property is set to false, and the <strong>error</strong> is assigned to state’s <strong>message</strong> property.</li>
<li>In case no <strong>error</strong> property, we set the state to <strong>true</strong>, and give its <strong>createdRoomRoute</strong> the value of the <strong>roomName</strong> property resolved by the promise.</li>
</ul>
<h4 id="Inform-user-of-unsuccessful-room-creation-or-send-them-to-their-room"><a href="#Inform-user-of-unsuccessful-room-creation-or-send-them-to-their-room" class="headerlink" title="Inform user of unsuccessful room creation, or send them to their room"></a>Inform user of unsuccessful room creation, or send them to their room</h4><p>We actually have all ingredients needed for both of these functionalities.</p>
<p>The unsuccessfull room creation I had in mind was a room name that is already in use. In case this happens, we will output the state <strong>message</strong> property (which is valid in case of <strong>error</strong> property resolved by the emitter function) in JSX:</p>
<figure class="highlight ts"><figcaption><span>src/component/communication-new-room.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> NewRoom: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot; row-span-2 w-full bg-gray-200 py-32&quot;</span>&gt;</span><br><span class="line">      &lt;form&gt;<span class="comment">/* ... */</span>&lt;/form&gt;</span><br><span class="line">      &#123;isCreated.message &amp;&amp; (</span><br><span class="line">        &lt;p className=<span class="string">&quot;mt-8 px-4 text-center text-orange-900&quot;</span>&gt;</span><br><span class="line">          &#123;isCreated.message&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>And in case all is good, and there is no <strong>error</strong> property resolved by the emitter promise, we redirect the user with help of <strong>Redirect</strong> component</p>
<figure class="highlight ts"><figcaption><span>src/component/communication-new-room.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> NewRoom: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot; row-span-2 w-full bg-gray-200 py-32&quot;</span>&gt;</span><br><span class="line">      &lt;form&gt;<span class="comment">/* ... */</span>&lt;/form&gt;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;isCreated.status &amp;&amp; (</span><br><span class="line">        &lt;Redirect to=&#123;<span class="string">`/chat/room/<span class="subst">$&#123;isCreated.createdRoomRoute&#125;</span>`</span>&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Define-the-emitter-function"><a href="#Define-the-emitter-function" class="headerlink" title="Define the emitter function"></a>Define the emitter function</h4><p>We already said that the emitter is an async function. We want it to be one, because we want to be able to get <strong>acknowledgment</strong> data from the <strong>emit</strong> method inside it before we return from the emitter.<br>Actually, this method is identical to the <strong>joinRoom</strong> method we created earlier, apart from the function and event names, of course.</p>
<p>Here it is:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addNewRoom = <span class="keyword">async</span> (roomName: <span class="built_in">string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!socketRef.current) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  roomName = roomName.trim();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> createResponse: &#123;</span><br><span class="line">    roomName: <span class="built_in">string</span>;</span><br><span class="line">    error: <span class="built_in">string</span>;</span><br><span class="line">  &#125; = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    socketRef.current?.emit(</span><br><span class="line">      <span class="string">&quot;createRoom&quot;</span>,</span><br><span class="line">      &#123; name: loggedUser, room: roomName &#125;,</span><br><span class="line">      (</span><br><span class="line">        response: PromiseLike&lt;&#123; roomName: <span class="built_in">string</span>; error: <span class="built_in">string</span> &#125;&gt; | <span class="literal">undefined</span></span><br><span class="line">      ) =&gt; resolve(response)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createResponse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As with the <strong>joinRoom</strong> function, the <strong>async</strong> keyword on the <strong>addNewRoom</strong> allows us to <strong>await</strong> for the resolution of the emitter’s <strong>acknowledgment</strong> function in the promise we created.<br>Then, we can resutrn the resolved values.</p>
<p>Of course, now we need to type this function into the context’s generic types, and pass it via its <strong>Provider</strong>‘s <strong>value</strong> prop.<br>We know how to do that by now.</p>
<h4 id="New-room-event-listener-on-backend"><a href="#New-room-event-listener-on-backend" class="headerlink" title="New room event listener on backend"></a>New room event listener on backend</h4><p>We need to do few things on backend:</p>
<ul>
<li>Set up an event listener</li>
<li>Define an call a function in <strong>rooms</strong> module that creates a new room</li>
<li>Use <strong>ack</strong> functin to return errors and confirmations of a created room</li>
<li>Use <strong>addUserToRoom()</strong> and <strong>join()</strong> methods to join user to a room</li>
</ul>
<p><strong>The event listener</strong></p>
<p>The event listener for the new room is just another event listener. In fact, apart from an extra step to create the room in the <strong>rooms</strong> array of the <strong>rooms</strong> module, it is identical to the event listener for joining rooms.<br>This means that we should probably dry up this code somehow, and I hope to do it in the next series.</p>
<p>Here is the code, so you can see what I mean:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; addUserToRoom, createRoom &#125; <span class="keyword">from</span> <span class="string">&quot;./rooms&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&quot;createRoom&quot;</span>, <span class="keyword">async</span> (data: &#123; name: <span class="built_in">string</span>; room: <span class="built_in">string</span> &#125;, ack) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; error, roomName &#125; = createRoom(data.room);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> ack(&#123; error &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; error: addToRoomError, username &#125; = addUserToRoom(</span><br><span class="line">    data.name,</span><br><span class="line">    roomName <span class="keyword">as</span> <span class="built_in">string</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addToRoomError) <span class="keyword">return</span> ack(&#123; error: addToRoomError &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    resolve(</span><br><span class="line">      socket.join(data.room, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123; name: <span class="string">&quot;admin&quot;</span>, content: <span class="string">`Welcome`</span> &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.to(data.room).emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123;</span><br><span class="line">            name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            content: <span class="string">`<span class="subst">$&#123;data.name&#125;</span> &quot;has joined the room`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        io.to(data.room).emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">          message: &#123;</span><br><span class="line">            name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            content: <span class="string">`You all have fun`</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          room: data.room,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(socket.rooms).includes(data.room)) <span class="keyword">return</span> ack(&#123; error &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ack(&#123; roomName: data.room &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>As you can see, here we also return an error if we cannot add user to the room, and we also wait for resolution of Socket.io joining user to the room, before we acknowledge that the join was a success.</p>
<p>The only difference, actual creation of the room, involves a call to the <strong>createRoom</strong> function. If the call returns an <strong>error</strong> property, we infrom frontend that there is an error. If all good, we move on with the code</p>
<p>So let’s create the <strong>createRoom</strong> function.<br>We do it in the <strong>rooms</strong> module, and for now the rooms we create will be just strings inside the <strong>rooms</strong> array. Lots of rooms.</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/rooms.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createRoom = <span class="function">(<span class="params">roomName: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  roomName = roomName.trim();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check if this room already exists</span></span><br><span class="line">  <span class="keyword">const</span> isRoomExist = rooms.includes(roomName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRoomExist)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      error: <span class="string">&quot;Room name is already taken&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if it doesnt exist, we add to the array</span></span><br><span class="line">  rooms.push(roomName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   and we finally can return room name if all is good .</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    roomName,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As you can see, we take a string argument (the actual room name), to check if it exists in the said array. If so, we return an object with the <strong>error</strong> property to say that the room name is already taken.<br>If all good, we return an object with the room name.</p>
<p>With this, the backend part is done.<br>Now, when the user submits a new room name, the name is verified, and if all good, the user is redirected to the new room. Lovely.</p>
<h3 id="Join-room-functionality"><a href="#Join-room-functionality" class="headerlink" title="Join room functionality"></a>Join room functionality</h3><p>Well, this we don’t need to go over. Implementation of this feature is the same as the previous one. We have a component that provides name of the room to be joined. This string is sent to backend to check if the room exists, and if all good, we redirect the user to the room’s path on frontend.</p>
<p>In fact, we already have the <strong>joinRoom</strong> function defined in the <strong>MessagesProvider</strong> component, ready for this feature. Backend also has an event listener waiting for <strong>join</strong> event. Even the component used for the feature differs from the <strong>NewRoom</strong> component only in labels.</p>
<p>With all of this being said, it is obvious we should dry up all of this somehow. Sure, we will.<br>Until then, code for this functionality is on Github.</p>
<h4 id="Show-if-a-new-message-arrived-in-a-room-that-is-not-viewed-at-the-moment"><a href="#Show-if-a-new-message-arrived-in-a-room-that-is-not-viewed-at-the-moment" class="headerlink" title="Show if a new message arrived in a room that is not viewed at the moment"></a>Show if a new message arrived in a room that is not viewed at the moment</h4><p>This one is interesting.<br>We want the app to render all contacts with unseen messages in red color.<br>How to do that?</p>
<p>Here is an idea:</p>
<ul>
<li>Each communication object in the <strong>MessagesProvider</strong>‘s state has a <strong>seen</strong> property. We already have this implemented.</li>
<li>This property is set to false every time a new message arrives to a communcation object. We already have this implemented as well.</li>
<li>Now, when we pass list of communications to the <strong>Contacts</strong> container, we pass this property as sell. Well what do you know, we have this covered, too.</li>
<li>Inside the <strong>ContactItem</strong> component, rendered by the <strong>Contacts</strong> container by mapping over the <strong>generateCommunicationList</strong>, we set the message to be rendered in red color if the <strong>seen</strong> value is false. Otherwise, the color is a shade of gray.</li>
<li>Now, to make sure that the color is not red when we see the message, we want change this <strong>seen</strong> property to <strong>true</strong> when the current URL matches the <strong>room</strong> prop of each rendered <strong>ContactItem</strong> component.</li>
<li>To do this, we define a function in <strong>MessagesProvider</strong> component, and have it switch <strong>seen</strong> property to true for a room that matches its argument. This function is then passed to the <strong>ContactItem</strong> component via context, and called in <strong>useEffect</strong> in case if the route matches the room name, and when both URL or the component’s message content changes.</li>
</ul>
<p>Let’s start by appliyng some conditional styling to the the <strong>ContactItem</strong> component:</p>
<figure class="highlight ts"><figcaption><span>src/components/contact-item.component.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link, useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ContactItemProps &#123;</span><br><span class="line">  setCommObjectRead: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  room: <span class="built_in">string</span>;</span><br><span class="line">  seen: <span class="built_in">boolean</span>;</span><br><span class="line">  author: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ContactItem: React.FC&lt;ContactItemProps&gt; = (&#123;</span><br><span class="line">  room,</span><br><span class="line">  seen,</span><br><span class="line">  author,</span><br><span class="line">  content,</span><br><span class="line">  setCommObjectRead,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = useLocation&lt;&#123; pathname: <span class="built_in">string</span> &#125;&gt;();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> param = pathname.split(<span class="string">&quot;/&quot;</span>)[<span class="number">3</span>];</span><br><span class="line">    param === room &amp;&amp; setCommObjectRead(room);</span><br><span class="line">  &#125;, [pathname, content]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Link to=&#123;<span class="string">`/chat/room/<span class="subst">$&#123;room&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;li className=<span class="string">&quot;flex justify-start py-4 border-b w-full&quot;</span>&gt;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &lt;div className=<span class="string">&quot;sm:flex justify-start flex-wrap ml-4 w-4/6 items-center hidden&quot;</span>&gt;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &lt;p</span><br><span class="line">            className=&#123;<span class="string">`text-sm w-full <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">              !seen ? <span class="string">&quot;text-red-600 &quot;</span> : <span class="string">&quot;text-gray-600&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span>`</span>&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;author&#125;: &#123;content&#125;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ContactItem;</span><br></pre></td></tr></table></figure>

<p>We added few more things, too:</p>
<ul>
<li>We import React Router’s <strong>useLocation</strong> hook, and inside <strong>useEffect</strong> hook we split its <strong>pathname</strong> property in order to get the current URL. We couldn’t use the <strong>useParams</strong> hook in this component (I think) because this component is not rendered by React Router’s <strong>Route</strong> component.</li>
<li>The <strong>setCommObjectRead</strong> is the function that sets <strong>seen</strong> property to true for the room currently in view. We get this function as a prop from the <strong>Contacts</strong> container, which in turn gets it from the context. A bit convulted, I know, and this should probably changed in future.</li>
<li>In any case, <strong>setCommObjectRead</strong> is called when the room matches the split <strong>pathname</strong> value. We need the fourth item in the split array, as the URL of a room view has a pattern of <strong>“domain/chat/room/<ROOM_NAME>“</strong>.</li>
</ul>
<p>That’s it.<br>Now to define the function in <strong>MessagesProvider</strong>.<br>The function just takes its argument and calls the <strong>communicationObjects</strong> setter.<br>Inside the setter, we search for the room object that matches the argument, and return existing state if no such room exists.<br>If the room exists, we find its index, to be able to place its object back into the original place, so as not to mess up the order of room objects.<br>Of course, the room object that we return has its <strong>seen</strong> property switched to <strong>true</strong></p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setCommObjectRead = <span class="function">(<span class="params">roomName: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  setCommunicationObjects(<span class="function">(<span class="params">prevObjs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentRoom = prevObjs.find(<span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> room.room === roomName;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentRoom) <span class="keyword">return</span> prevObjs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> currentRoomIndex = prevObjs.findIndex(<span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> room.room === roomName;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newObjects = [...prevObjs];</span><br><span class="line"></span><br><span class="line">    newObjects[currentRoomIndex] = &#123;</span><br><span class="line">      ...currentRoom,</span><br><span class="line">      seen: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObjects;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>With this setup, we should be able to have our <strong>ContactItem</strong> components colored red whenever a new message for a particular room arrives.<br>Lovely.</p>
<h3 id="Disconnect-user-from-the-chat"><a href="#Disconnect-user-from-the-chat" class="headerlink" title="Disconnect user from the chat"></a>Disconnect user from the chat</h3><p>Finally, we reach the last part of this post. Line nr. 1761. Aiming for 2000.</p>
<p>We want to disconnect the user from the Server.io once they leave the app. That is the problem that we work with.<br>Few things need to happen:</p>
<ul>
<li>We want to clean up the frontend, so as not to have any memory leaks by leaving the connection active. I don’t think they would happen in our app anyway, since leaving the <strong>chat</strong> part of the app means either navigating away completely, or refreshing the app. In either way, the <strong>MessagesProvider</strong> component that holds the <strong>Socket.io</strong> connection gets unmounted. Still, we shall clean up.</li>
<li>We also want to close the connection on backend. When the Socket.io server detects the <strong>disconnect</strong> event, we want to tell other who has left the chat, and then close the connection.</li>
</ul>
<p>Since we already have a good portion of the required steps completed, I will include them here:</p>
<figure class="highlight ts"><figcaption><span>src/contexts/messages.context</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MessagesProvider: React.FC&lt;MessagesProvideProps&gt; = (&#123;</span><br><span class="line">  children,</span><br><span class="line">  loggedUser,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> socketRef = useRef&lt;SocketIOClient.Socket&gt;();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!loggedUser) <span class="keyword">return</span>;</span><br><span class="line">    socketRef.current = io.connect(<span class="string">&quot;localhost:5000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      socketRef.current?.emit(<span class="string">&quot;disconnect&quot;</span>);</span><br><span class="line">      socketRef.current?.disconnect();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Here we see that we return a function from the <strong>useEffect</strong> hook in <strong>MessagesProvider</strong>. This function calls <strong>emit</strong> method on the current Socket.io connection to emit a <strong>disconnect</strong> event.<br>The function also calls the <strong>disconnect</strong> method to explicitely disconnect the current client from the Socket.io servier to which has been connected.</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ioServer = <span class="function">(<span class="params">server: http.Server</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> io = socketio(server);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connection established on io server object</span></span><br><span class="line">  io.on(<span class="string">&quot;connect&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;We have a connection from socket nr.&quot;</span>, socket.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit admin message when connection established</span></span><br><span class="line">    socket.emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">      room: <span class="string">&quot;lobby&quot;</span>,</span><br><span class="line">      message: &#123;</span><br><span class="line">        name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        content: <span class="string">`Dear random user with socket id, <span class="subst">$&#123;socket.id&#125;</span>, welcome to the chat`</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disconnect event received on the socket object</span></span><br><span class="line">    socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;User with id of&quot;</span>, socket.id, <span class="string">&quot;has disconnected&quot;</span>);</span><br><span class="line">      socket.disconnect(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ioServer;</span><br></pre></td></tr></table></figure>

<p>On backend, we catch the <strong>disconnect</strong> event, and call <strong>disconnect</strong> method on the connected <strong>socket</strong> object.<br>At the moment we only log the <strong>id</strong> of the <strong>socket</strong> that has disconnected, but lets use that <strong>id</strong> to fetch the username of the user that has disconnected.</p>
<p>Since we previously added <strong>socketId</strong> property to each user object in <strong>rooms</strong> module, this shouldn’t be a problem:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/rooms.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeUser = <span class="function">(<span class="params">id: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!id) <span class="keyword">return</span> &#123; error: <span class="string">&quot;No id provided&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userForRemoval = users.find(<span class="function">(<span class="params">user</span>) =&gt;</span> user.socketID === id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!userForRemoval) <span class="keyword">return</span> &#123; error: <span class="string">&quot;No such user&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userIndex = users.findIndex(<span class="function">(<span class="params">user</span>) =&gt;</span> user.socketID === id);</span><br><span class="line"></span><br><span class="line">  users.splice(userIndex, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; username: userForRemoval.username &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>That’s it. If no such user, we return object with an <strong>error</strong> property. If we do find the user, then the return object has <strong>username</strong> property.</p>
<p>Now, we use the <strong>username</strong> property to inform other users in the <strong>lobby</strong> room of the sudden departure:</p>
<figure class="highlight ts"><figcaption><span>src/socket-io/server.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;the socket has disconnected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; error, username &#125; = removeUser(socket.id);</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="built_in">console</span>.log(<span class="string">&quot;There is no such user&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  io.emit(<span class="string">&quot;adminMessage&quot;</span>, &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      name: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      content: <span class="string">`<span class="subst">$&#123;username&#125;</span> has left the chat`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    room: <span class="string">&quot;lobby&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socket.disconnect(<span class="literal">true</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Here, we destructure both properties from <strong>removeUser</strong>s returned object.<br>We also send an <strong>adminMessage</strong> event to everyone using the chat at the moment. We shape the emitted object in such way that it will be shown only in the <strong>lobby</strong> room.<br>Finally, we close the connection with the socket.</p>
<p>Ok, this was long. Just shy of 1950 lines - way longer that I imagined. Still, we have done a lot. We actually built the app.<br>We planned it, figured out features, and implemented those features.<br>We switched a lot between backend and frontend, to make sure emitting events are sent and caught, and we even implemented a fancy featrue to have the app notify us of new messages.</p>
<p>In the next post we will deploy the app. We will deploy both ends on Heroku. See you there.</p>
<!-- End Step Content -->

<!-- Project Information -->

<h2 id="Project-Information"><a href="#Project-Information" class="headerlink" title="Project Information"></a>Project Information</h2><h3 id="Available-at"><a href="#Available-at" class="headerlink" title="Available at"></a>Available at</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ikaem/shima-api">Github repository - api</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ikaem/shima-react-webpack">Github repository - frontend</a></li>
<li><a target="_blank" rel="noopener" href="https://shima-react-webpack.herokuapp.com/">Live website</a></li>
</ul>
<h3 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h3><ol>
<li>Use Socket.io to create a chat app</li>
<li>Use Webpack, Babel, and TypeScript with React</li>
<li>Deploy Webpack React app to Heroku</li>
</ol>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><ol>
<li>Create a React app with Webpack</li>
<li>Set up backend</li>
<li>Organize the React app</li>
<li><strong>Building the app</strong></li>
<li>Deployment and known issues</li>
</ol>
<h3 id="Tech-and-Tools"><a href="#Tech-and-Tools" class="headerlink" title="Tech and Tools"></a>Tech and Tools</h3><ul>
<li>React</li>
<li>Tailwind</li>
<li>Webpack</li>
<li>Babel</li>
<li>TypeScript</li>
<li>Socket.io</li>
<li>Express</li>
</ul>
<h3 id="Experience-with-Tech-amp-Tools"><a href="#Experience-with-Tech-amp-Tools" class="headerlink" title="Experience with Tech &amp; Tools"></a>Experience with Tech &amp; Tools</h3><p>I have done few smaller apps with Webpack, as described on this blog, so I have basic understanding of what Webpack is used for and how it does what it does. I also did a very small app with Socket.io on one occasion before, to see what it is all about. Babel I am completely unfamiliar with, so let’s see what it is.<br>Rest of the tech is familiar, and I shouldn’t have bigger problems using those.</p>
<h2 id="DISCLAIMER"><a href="#DISCLAIMER" class="headerlink" title="DISCLAIMER"></a>DISCLAIMER</h2><p>Don’t take any of this seriously and as a matter-of-fact. These are my notes. It might look like I am trying to teach something to someone. I am not.</p>
<p>Also, this post, and the whole blog, is not meant for a codealong. This is my notebook, and I learn these things by writing about them.<br>While I try to structure posts and organize them in a way that they build on previous posts’ progress, I can’t promise that they will include all details needed for the code to work. There is just too much of it, and I might omit things for brevity sake, or because I forgot something, or because I am not well organized, or because I changed my mind and reworked the code at the end of a blog series.</p>


                


                <!-- Cover image credit -->
                
                    <p class="image-credit-link">
                        Cover image by <strong>
                            <a target="_blank" rel="noopener" href="https://unsplash.com/@nelmin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">
                                Evgeny Nelmin
                            </a>
                        </strong>
                    </p>

                

  

            </div>
            
            <!-- Custom placed tags -->
            <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                
                    


<a href="/angry-chaired-blog/tags/typescript/">#typescript</a> <a href="/angry-chaired-blog/tags/express/">#express</a> <a href="/angry-chaired-blog/tags/react/">#react</a> <a href="/angry-chaired-blog/tags/socketio/">#socketio</a> <a href="/angry-chaired-blog/tags/react-router/">#react-router</a>


                
            </div>
            <!--  -->



            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            

            <!-- Hyvor comments -->

            <!-- End of Hyvor comments -->
        </div>
    </div>
</article>



    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 kaem<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>